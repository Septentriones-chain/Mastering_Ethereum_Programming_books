# Ch2 이더리움 플랫폼의 작동 원리

## 2.1 이더리움 플랫폼 살펴보기

- 플랫폼

> 일련의 소프트웨어 프로그램을 작동되게 하는 프레임워크
>



### 2.1.1 이더리움 작동 과정

- 스마트 컨트랙트

> 네트워크 상에서 신뢰할 수 없는 대상 간에 서로 합의한 계약을 준수하도록 강제하는 도구



![image-20181012012648533](/Users/yegenieee/Desktop/2-1이더리움 플랫폼의 작동 과정.png)

1. 사용자는 이더를 사용하기 위해 Mist 나 Ethereum Wallet을 설치함 (이들은 내부에 이더리움 클라이언트를 내장하고 있어서, 작동시 바로 이더리움 네트워크에 연결됨) & 계정을 생성 (EOA) - passphrase를 입력하여 계정 생성, 최초 account가 만들어지면 그게 바로 main account가 됨 = etherbase

2. 빗썸이나 업비트같은 외부 거래소에서 Ether를 구입

3. 다른 사용자에게서 Ether 받는 방법도 있음

4. 상품이나 서비스를 Ether로 구매할 수 있음

5. 상품이나 서비스를 판매하여 Ether를 획득할 수 있음

6. 채굴 : 블록을 새로 생성하여 블록체인에 연결하는 일

   트랜잭션들을 모아 하나의 블록을 생성하는데, 그 블록을 validation 하는 작업이라고 볼 수 있음

   **정확히 말하면, 블록 헤더에 존재하는 해시값을 뛰어넘지 않는 최대 근사값을 찾는 행위 **

7. 이더리움 플랫폼 개발자들은 이더리움 플랫폼을 개발

8. Dapp 개발자들은 스마트 컨트랙트 기반의 응용 서비스를 개발



> 중앙 집중 원장에서는 중앙 은행이 각 트랜잭션의 이상을 알아채고, 이를 보장해주지만,
>
> 분산 공유 원장은 중앙의 인증 기관이 없는 형태 --> 이에 따른 문제가 생길 수 있음

![image-20181012020304241](/Users/yegenieee/Desktop/1-1중앙집중원장과분산공유원장.png)







지연이나 미도달로 인해 발생하는 double spending 등의 문제 해결 위해 Consensus 알고리즘 이용

**Consensus Algorithm**을 통해 해당 트랜잭션 데이터가 정확하고 문제가 없는지를 확인함

- Consensus
  - Ethereum에서의 Consensus
    - 컴퓨팅 연산을 통해 블록 헤더의 난이도 보다 적은 해시값을 찾아냄
    - 해당 해시값 찾으면, 모든 노드들에게 브로드캐스팅
    - 가장 빠르게 이 해시값을 찾아내는 채굴자가 블록 당 3 Ether와 트랜잭션 내 수수료를 먹음

  - PoW (작업 증명 : Proof of Work)
    - 블록체인에 새로운 블록을 추가하려면, 그 새로운 블록의 블록 해쉬를 계산해내야하고, 그 블록 해쉬를 계산해내려면 그 블록의 블록 헤더 정보 중의 하나인 `nonce`값을 계산을 통해 구해야 한다.
    - 결국 ```nonce``` 값 구하기
    - ```nonce```값을 해시 입력값 중 하나로 하여, 계산되는 해시값이 특정 숫자보다 작아지면 됨 ==> 이게 블록을 블록체인에 추가하는 것

    ![image-20181012142548031](/Users/yegenieee/Desktop/이미지/image-20181012142548031.png)

    - 특정 숫자 : 난이도에 의해 결정되는 값

    - 난이도는 블록 헤더의 ```Bits``` 를 통해 조절됨

    - PoW에서는 **가장 빨리 채굴된 블록만 인정을 받고 나머지는 버려지게 되기 때문에 이중지불 문제가 해결**됨

      > 여기서 PoW에 대해 의문점은 거대 자본가가 슈퍼컴퓨터를 구입하여 연산을 돌린다면 분산된 장부작성 방식이 아닌 중앙집권적 방식이 되지 않을까 할 수 있음
      > 그러나, 과반수의 해시파워를 가진 컴퓨터를 구매하는 건 엄청나게 많은 돈이 들어갑니다. 만약 천문학적인 돈을 투자하여 구매했다 하더라도, 거래가 위조되고 부당한 장부라고 느낀다면 해당 블록체인의 가치가 급락할 것이기 때문에 정당한 방식으로 네트워크를 운영하는 것이 훨씬 큰 이득입니다.

      - 장점

        > 서비스 남용을 쉽게 방지
        >
        > 강력한 보안성

      - 단점

        > 난이도가 높아짐에따라 고사양 장비가 필요 (GPU) --> 에너지 낭비의 문제
        >
        > 지속적으로 해시파워를 유지해야 함
        >
        > 개인 채굴자는 보상을 얻기 힘들어짐 (채굴의 기업화로 인해)

  - PoS (지분 증명 : Proof of Stake)

    - 본인이 소유한 코인 지분으로 채굴하는 방식

    - 코인을 가지고 있는 사용자가 현재 보유하고 있는 자산 (stake)에 비례하여 블록을 생성할 권한을 더 많이 부여

    - 블록 생성자와 지분 생성자의 이해관계를 일치시킴으로써 블록을 나쁜 의도로 생성할 동기부여를 없애며, 잘못 생성할 경우 패널티를 부여
      - 장점

        > 해시파워가 많이 필요하지 않아 에너지 낭비가 적음

      - 단점

        > 지분을 51% 가지고 있는 A 사용자가 자기의 이익에 반하는 B 사용자의 자산을 삭제해서 A가 B의 자산 을 0으로 만들어버릴 수도 있음
        >
        > 모두 이자를 받으려고 코인을 묶어놓기 때문에 시중 코인의 유통량 감소로 이어질 수 있음

    - 그럼에도 PoS로 전환하려는 이유

      > - PoW에서 51%의 해시파워를 가지는 비용 = 약 2500억원
      >
      > - PoS에서 전 세계 자산의 51% = 약 25조원
      >
      >   ==> PoS가 중앙집권화가 더 어렵다는 이점이 있음



## 2.2 이더리움 단일 상태 모델 

### 2.2.1 이더리움 상태 전이 모델

#### 현실 세계에서의 거래

![image-20181012175320596](/Users/yegenieee/Desktop/이미지/image-20181012175320596.png)

- 거래가 발생할 때 마다, 계좌의 상태가 변함
- 시간에 따라 순서를 가지고, 서로 영향을 주고 받으며 중앙 은행 원장에 관련 정보를 모두 기록하게 됨
- 이렇게 되면, 중앙의 은행에서만 트랜잭션을 관리하면 유효성 검증까지 다 할 수 있음



#### 이더리움에서의 거래, 상태 전이

- 상태 전이 과정을 기반으로 작동

##### 상태 전이

> 특정 시점의 현재 상태 : ```S```
>
> 상태 변이 함수 : ```APPLY()```
>
> 다른 상태 : ```S'```
>
> ![image-20181012181857930](/Users/yegenieee/Desktop/이미지/image-20181012181857930.png)



- 이더리움 안에서의 기본 단위 : Account - 특정 주소가 있음, 필요한 데이터 저장을 위한 저장 공간도 가지고 있음 : state
- **이더리움의 전체 상태 == 전체 어카운트의 상태**
  - 상태 변이 함수 (APPLY())에 의해 전이
  - 이 함수는 송금이 될 수도, 스마트 컨트랙트가 될 수도 있음



- 상태 전이

![image-20181012182203999](/Users/yegenieee/Desktop/이미지/image-20181012182203999.png)



- 이더리움의 블록 체인
  - 상태 전이에 관련된 state들과 transaction 들을 블록으로 구성

![image-20181012182243909](/Users/yegenieee/Desktop/이미지/image-20181012182243909.png)



### 비트코인 상태 정보 모델

- 비트코인에서의 상태 : UTXO
  - 결국 비트코인에서는 balance만 변동하는 것만 가능

![image-20181012182653011](/Users/yegenieee/Desktop/이미지/image-20181012182653011.png)

![image-20181012182455169](/Users/yegenieee/Desktop/이미지/image-20181012182455169.png)



### 2.2.2 이더리움 플랫폼 참조 모델

- Go로 개발된 이더리움 플랫폼
  - 하나의 노드에서 모두 작동